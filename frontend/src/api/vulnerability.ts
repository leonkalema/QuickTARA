/**
 * API client for vulnerability assessment
 */
import { apiClient } from './index';

// Enums
export enum VulnerabilitySeverity {
  LOW = 'Low',
  MEDIUM = 'Medium',
  HIGH = 'High',
  CRITICAL = 'Critical'
}

export enum AttackVector {
  NETWORK = 'Network',
  ADJACENT = 'Adjacent',
  LOCAL = 'Local',
  PHYSICAL = 'Physical'
}

export enum AttackComplexity {
  LOW = 'Low',
  HIGH = 'High'
}

export enum PrivilegesRequired {
  NONE = 'None',
  LOW = 'Low',
  HIGH = 'High'
}

export enum UserInteraction {
  NONE = 'None',
  REQUIRED = 'Required'
}

export enum Scope {
  UNCHANGED = 'Unchanged',
  CHANGED = 'Changed'
}

export enum ImpactLevel {
  NONE = 'None',
  LOW = 'Low',
  HIGH = 'High'
}

export enum MitigationStatus {
  NOT_STARTED = 'Not Started',
  IN_PROGRESS = 'In Progress',
  MITIGATED = 'Mitigated'
}

export enum DetectionMethod {
  MANUAL = 'Manual',
  AUTOMATED = 'Automated',
  HYBRID = 'Hybrid'
}

// Interfaces
export interface Vulnerability {
  vulnerability_id: string;
  name: string;
  description: string | null;
  severity: VulnerabilitySeverity;
  cvss_score: number | null;
  cvss_vector: string | null;
  affected_components: string[];
  attack_vector: AttackVector | null;
  attack_complexity: AttackComplexity | null;
  privileges_required: PrivilegesRequired | null;
  user_interaction: UserInteraction | null;
  scope: Scope | null;
  confidentiality_impact: ImpactLevel | null;
  integrity_impact: ImpactLevel | null;
  availability_impact: ImpactLevel | null;
  exploitability_score: number | null;
  impact_score: number | null;
  created_at: string;
  updated_at: string;
}

export interface VulnerabilityCreate {
  name: string;
  description?: string;
  severity: VulnerabilitySeverity;
  cvss_score?: number;
  cvss_vector?: string;
  affected_components?: string[];
  attack_vector?: AttackVector;
  attack_complexity?: AttackComplexity;
  privileges_required?: PrivilegesRequired;
  user_interaction?: UserInteraction;
  scope?: Scope;
  confidentiality_impact?: ImpactLevel;
  integrity_impact?: ImpactLevel;
  availability_impact?: ImpactLevel;
  exploitability_score?: number;
  impact_score?: number;
  vulnerability_id?: string;
}

export interface VulnerabilityUpdate {
  name?: string;
  description?: string;
  severity?: VulnerabilitySeverity;
  cvss_score?: number;
  cvss_vector?: string;
  affected_components?: string[];
  attack_vector?: AttackVector;
  attack_complexity?: AttackComplexity;
  privileges_required?: PrivilegesRequired;
  user_interaction?: UserInteraction;
  scope?: Scope;
  confidentiality_impact?: ImpactLevel;
  integrity_impact?: ImpactLevel;
  availability_impact?: ImpactLevel;
  exploitability_score?: number;
  impact_score?: number;
}

export interface VulnerabilityList {
  vulnerabilities: Vulnerability[];
  total: number;
}

export interface ComponentVulnerabilityAssessment {
  component_id: string;
  component_name: string;
  component_type: string;
  total_vulnerabilities: number;
  high_severity_vulnerabilities: number;
  vulnerability_ids: string[];
}

export interface VulnerabilityAssessmentResult {
  assessment_id: string;
  component_assessments: ComponentVulnerabilityAssessment[];
  total_components: number;
  total_vulnerabilities: number;
  high_severity_vulnerabilities: number;
  created_at: string;
  scope_id: string | null;
}

/**
 * Get vulnerabilities with optional filtering
 * 
 * @param skip - Number of items to skip for pagination
 * @param limit - Maximum number of items to return
 * @param componentId - Optional component ID to filter by
 * @param severity - Optional severity level to filter by
 * @returns Promise with the list of vulnerabilities and total count
 */
export async function getVulnerabilities(
  skip: number = 0,
  limit: number = 100,
  componentId?: string,
  severity?: VulnerabilitySeverity
): Promise<VulnerabilityList> {
  try {
    let queryParams = new URLSearchParams();
    queryParams.append('skip', skip.toString());
    queryParams.append('limit', limit.toString());
    
    if (componentId) {
      queryParams.append('component_id', componentId);
    }
    
    if (severity) {
      queryParams.append('severity', severity);
    }
    
    console.log('Fetching vulnerabilities with params:', queryParams.toString());
    const response = await apiClient.get<VulnerabilityList>(`/vulnerability?${queryParams.toString()}`);
    return response;
  } catch (error) {
    console.error('Error fetching vulnerabilities:', error);
    throw error; // Re-throw to allow handling in component
  }
}

/**
 * Get a vulnerability by ID
 * 
 * @param vulnerabilityId - ID of the vulnerability to retrieve
 * @returns Promise with the vulnerability details
 */
export async function getVulnerability(vulnerabilityId: string): Promise<Vulnerability> {
  try {
    const response = await apiClient.get<Vulnerability>(`/vulnerability/${vulnerabilityId}`);
    return response;
  } catch (error) {
    console.error(`Error fetching vulnerability ${vulnerabilityId}:`, error);
    throw error;
  }
}

/**
 * Create a new vulnerability
 * 
 * @param vulnerability - Vulnerability details to create
 * @returns Promise with the created vulnerability
 */
export async function createVulnerability(vulnerability: VulnerabilityCreate): Promise<Vulnerability> {
  try {
    const response = await apiClient.post<Vulnerability>('/vulnerability', vulnerability);
    return response;
  } catch (error) {
    console.error('Error creating vulnerability:', error);
    throw error;
  }
}

/**
 * Update an existing vulnerability
 * 
 * @param vulnerabilityId - ID of the vulnerability to update
 * @param vulnerabilityUpdate - Updated vulnerability fields
 * @returns Promise with the updated vulnerability
 */
export async function updateVulnerability(
  vulnerabilityId: string,
  vulnerabilityUpdate: VulnerabilityUpdate
): Promise<Vulnerability> {
  try {
    // Log the outgoing request for debugging
    console.log('Updating vulnerability with ID:', vulnerabilityId);
    console.log('Update payload:', JSON.stringify(vulnerabilityUpdate, null, 2));
    
    // Make sure to remove any undefined values from the update payload
    const cleanedUpdate = Object.fromEntries(
      Object.entries(vulnerabilityUpdate).filter(([_, value]) => value !== undefined)
    );
    
    console.log('Cleaned update payload:', JSON.stringify(cleanedUpdate, null, 2));
    
    const response = await apiClient.put<Vulnerability>(
      `/vulnerability/${vulnerabilityId}`,
      cleanedUpdate
    );
    return response;
  } catch (error) {
    // Log detailed error information
    console.error(`Error updating vulnerability ${vulnerabilityId}:`, error);
    
    // If the error has a response, log the details
    if (error && typeof error === 'object' && 'data' in error) {
      console.error('Error data:', error.data);
      if (error.data?.detail) {
        console.error('Error detail:', error.data.detail);
      }
    }
    
    throw error;
  }
}

/**
 * Delete a vulnerability
 * 
 * @param vulnerabilityId - ID of the vulnerability to delete
 * @returns Promise that resolves when the vulnerability is deleted
 */
export async function deleteVulnerability(vulnerabilityId: string): Promise<void> {
  try {
    await apiClient.delete(`/vulnerability/${vulnerabilityId}`);
  } catch (error) {
    console.error(`Error deleting vulnerability ${vulnerabilityId}:`, error);
    throw error;
  }
}

/**
 * Perform vulnerability assessment on components
 * 
 * This function sends component IDs to the vulnerability assessment API endpoint
 * and returns assessment results. The assessment identifies potential vulnerabilities
 * for each component based on its type, interfaces, and trust zone configuration.
 * 
 * @param componentIds - Array of component IDs to assess
 * @returns Promise with the vulnerability assessment results
 * 
 * @example
 * // Assess vulnerabilities for specific components
 * const assessmentResult = await performVulnerabilityAssessment(['BMS001', 'BMS002']);
 * 
 * // Handle the results
 * console.log(`Found ${assessmentResult.total_vulnerabilities} vulnerabilities`);
 */
export async function performVulnerabilityAssessment(
  componentIds: string[]
): Promise<VulnerabilityAssessmentResult> {
  try {
    // Simple request body with component IDs
    const requestBody = componentIds;

    console.log('Sending vulnerability assessment request:', requestBody);
    
    // Make the API call with more explicit error handling
    const response = await apiClient.post<VulnerabilityAssessmentResult>(
      '/vulnerability/assess',
      requestBody,
      {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      }
    );
    
    // Log the full response for debugging
    console.log('Vulnerability assessment response:', response);
    
    // If response is undefined, throw an error
    if (!response) {
      throw new Error('No response received from vulnerability assessment API');
    }
    
    return response;
  } catch (error) {
    // Log the full error object for debugging
    console.error('Error in vulnerability assessment - Full details:', {
      error,
      message: error instanceof Error ? error.message : 'Unknown error',
      stack: error instanceof Error ? error.stack : undefined
    });
    
    // If it's an API error with details, extract and log them
    if (error && typeof error === 'object' && 'data' in error) {
      console.error('API error details:', error.data);
    }
    
    throw error; // Re-throw to allow handling in component
  }
}
