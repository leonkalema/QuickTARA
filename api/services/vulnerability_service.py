"""
Vulnerability assessment service
"""
import uuid
import json
from typing import List, Dict, Any, Optional
from datetime import datetime
from sqlalchemy.orm import Session
from fastapi import HTTPException, status

from db.base import Vulnerability, Component, SystemScope
from api.models.vulnerability import (
    VulnerabilityCreate, 
    VulnerabilityUpdate, 
    Vulnerability as VulnerabilityModel,
    VulnerabilityAssessmentResult
)
from api.models.component import Component as ComponentModel


def db_vulnerability_to_model(db_vulnerability: Vulnerability) -> VulnerabilityModel:
    """Helper function to convert database vulnerability to Pydantic model"""
    if not db_vulnerability:
        return None
        
    vuln_dict = {
        'vulnerability_id': db_vulnerability.vulnerability_id,
        'name': db_vulnerability.name,
        'description': db_vulnerability.description,
        'severity': db_vulnerability.severity,
        'cvss_score': db_vulnerability.cvss_score,
        'cvss_vector': db_vulnerability.cvss_vector,
        'affected_components': db_vulnerability.affected_components,
        'attack_vector': db_vulnerability.attack_vector,
        'attack_complexity': db_vulnerability.attack_complexity,
        'privileges_required': db_vulnerability.privileges_required,
        'user_interaction': db_vulnerability.user_interaction,
        'scope': db_vulnerability.scope,
        'confidentiality_impact': db_vulnerability.confidentiality_impact,
        'integrity_impact': db_vulnerability.integrity_impact,
        'availability_impact': db_vulnerability.availability_impact,
        'exploitability_score': db_vulnerability.exploitability_score,
        'impact_score': db_vulnerability.impact_score,
        'created_at': db_vulnerability.created_at,
        'updated_at': db_vulnerability.updated_at
    }
    
    # Handle JSON fields - SQLAlchemy might return string or list
    if isinstance(vuln_dict['affected_components'], str):
        try:
            vuln_dict['affected_components'] = json.loads(vuln_dict['affected_components'])
        except:
            vuln_dict['affected_components'] = []
    elif vuln_dict['affected_components'] is None:
        vuln_dict['affected_components'] = []
        
    return VulnerabilityModel(**vuln_dict)

# Mapping of component types to common vulnerabilities
COMPONENT_VULNERABILITY_MAPPING = {
    "ECU": [
        {
            "name": "Insufficient Authentication",
            "description": "The ECU implements weak or no authentication mechanisms, allowing unauthorized access.",
            "severity": "High",
            "attack_vector": "Network",
            "attack_complexity": "Low",
            "privileges_required": "None",
            "user_interaction": "None",
            "confidentiality_impact": "High",
            "integrity_impact": "High",
            "availability_impact": "Low",
            "cvss_score": 8.1
        },
        {
            "name": "Insecure Bootloader",
            "description": "The bootloader doesn't verify firmware signatures, allowing malicious firmware installation.",
            "severity": "Critical",
            "attack_vector": "Physical",
            "attack_complexity": "Low",
            "privileges_required": "None",
            "user_interaction": "None",
            "confidentiality_impact": "High",
            "integrity_impact": "High",
            "availability_impact": "High",
            "cvss_score": 9.0
        }
    ],
    "Sensor": [
        {
            "name": "Sensor Data Spoofing",
            "description": "The sensor accepts external inputs without sufficient validation, allowing spoofed data.",
            "severity": "High",
            "attack_vector": "Physical",
            "attack_complexity": "Low",
            "privileges_required": "Low",
            "user_interaction": "None",
            "confidentiality_impact": "Low",
            "integrity_impact": "High",
            "availability_impact": "High",
            "cvss_score": 7.7
        }
    ],
    "Gateway": [
        {
            "name": "Insecure Protocol Implementation",
            "description": "The gateway implements communication protocols without proper security controls.",
            "severity": "High",
            "attack_vector": "Network",
            "attack_complexity": "Low",
            "privileges_required": "None",
            "user_interaction": "None",
            "confidentiality_impact": "High",
            "integrity_impact": "High",
            "availability_impact": "Medium",
            "cvss_score": 8.6
        },
        {
            "name": "Inadequate Network Segmentation",
            "description": "The gateway doesn't properly segment networks of different trust levels.",
            "severity": "Medium",
            "attack_vector": "Network",
            "attack_complexity": "High",
            "privileges_required": "Low",
            "user_interaction": "None",
            "confidentiality_impact": "High",
            "integrity_impact": "Low",
            "availability_impact": "Low",
            "cvss_score": 5.3
        }
    ],
    "Actuator": [
        {
            "name": "Missing Input Validation",
            "description": "The actuator doesn't validate control commands, allowing unsafe operations.",
            "severity": "High",
            "attack_vector": "Network",
            "attack_complexity": "Low",
            "privileges_required": "Low",
            "user_interaction": "None",
            "confidentiality_impact": "Low",
            "integrity_impact": "High",
            "availability_impact": "High",
            "cvss_score": 7.8
        },
        {
            "name": "Lack of Command Authentication",
            "description": "Actuator accepts commands without verifying their authenticity.",
            "severity": "Critical",
            "attack_vector": "Network",
            "attack_complexity": "Low",
            "privileges_required": "None",
            "user_interaction": "None",
            "confidentiality_impact": "High",
            "integrity_impact": "High",
            "availability_impact": "High",
            "cvss_score": 9.8
        },
        {
            "name": "Weak Access Controls",
            "description": "The actuator has insufficient access controls on its network interface.",
            "severity": "Medium",
            "attack_vector": "Network",
            "attack_complexity": "Low",
            "privileges_required": "Low",
            "user_interaction": "None",
            "confidentiality_impact": "Medium",
            "integrity_impact": "Medium",
            "availability_impact": "Low",
            "cvss_score": 6.5
        }
    ]
}

# Interface-specific vulnerabilities
INTERFACE_VULNERABILITY_MAPPING = {
    "CAN": [
        {
            "name": "CAN Bus Message Injection",
            "description": "The system is vulnerable to CAN bus message injection attacks.",
            "severity": "High",
            "attack_vector": "Physical",
            "attack_complexity": "Low",
            "privileges_required": "None",
            "user_interaction": "None",
            "confidentiality_impact": "Low",
            "integrity_impact": "High",
            "availability_impact": "High",
            "cvss_score": 7.8
        },
        {
            "name": "CAN Bus Denial of Service",
            "description": "The CAN bus implementation is vulnerable to denial of service attacks.",
            "severity": "Medium",
            "attack_vector": "Physical",
            "attack_complexity": "Low",
            "privileges_required": "Low",
            "user_interaction": "None",
            "confidentiality_impact": "None",
            "integrity_impact": "None",
            "availability_impact": "High",
            "cvss_score": 6.2
        }
    ],
    "Bluetooth": [
        {
            "name": "Bluetooth Authentication Bypass",
            "description": "The Bluetooth implementation may allow authentication bypass.",
            "severity": "High",
            "attack_vector": "Adjacent",
            "attack_complexity": "Low",
            "privileges_required": "None",
            "user_interaction": "None",
            "confidentiality_impact": "High",
            "integrity_impact": "High",
            "availability_impact": "Low",
            "cvss_score": 8.3
        }
    ],
    "Wi-Fi": [
        {
            "name": "Weak Wi-Fi Security",
            "description": "The system uses outdated Wi-Fi security protocols.",
            "severity": "High",
            "attack_vector": "Adjacent",
            "attack_complexity": "Low",
            "privileges_required": "None",
            "user_interaction": "None",
            "confidentiality_impact": "High",
            "integrity_impact": "High",
            "availability_impact": "Medium",
            "cvss_score": 8.4
        }
    ],
    "Ethernet": [
        {
            "name": "Unencrypted Ethernet Traffic",
            "description": "Ethernet traffic is not encrypted, exposing sensitive data.",
            "severity": "Medium",
            "attack_vector": "Network",
            "attack_complexity": "Low",
            "privileges_required": "None",
            "user_interaction": "None",
            "confidentiality_impact": "High",
            "integrity_impact": "Low",
            "availability_impact": "Low",
            "cvss_score": 6.5
        }
    ]
}

# Trust zone to additional vulnerabilities mapping
TRUST_ZONE_VULNERABILITY_MAPPING = {
    "Untrusted": [
        {
            "name": "Insufficient Data Validation",
            "description": "Components in untrusted zones may process data without sufficient validation.",
            "severity": "High",
            "attack_vector": "Network",
            "attack_complexity": "Low",
            "privileges_required": "None",
            "user_interaction": "None",
            "confidentiality_impact": "High",
            "integrity_impact": "High",
            "availability_impact": "Medium",
            "cvss_score": 8.6
        }
    ],
    "Boundary": [
        {
            "name": "Weak Boundary Protection",
            "description": "Boundary components don't sufficiently protect trusted zones from untrusted ones.",
            "severity": "High",
            "attack_vector": "Network",
            "attack_complexity": "Low",
            "privileges_required": "Low",
            "user_interaction": "None",
            "confidentiality_impact": "High",
            "integrity_impact": "High",
            "availability_impact": "Medium",
            "cvss_score": 8.1
        }
    ]
}


def get_vulnerability_by_id(db: Session, vulnerability_id: str) -> Optional[VulnerabilityModel]:
    """Get a vulnerability by its ID"""
    db_vulnerability = db.query(Vulnerability).filter(Vulnerability.vulnerability_id == vulnerability_id).first()
    return db_vulnerability_to_model(db_vulnerability)


def get_vulnerabilities(
    db: Session, 
    component_id: Optional[str] = None,
    severity: Optional[str] = None,
    skip: int = 0, 
    limit: int = 100
) -> List[VulnerabilityModel]:
    """Get vulnerabilities with optional filtering"""
    query = db.query(Vulnerability)
    
    # Apply filters if provided
    if component_id:
        query = query.filter(Vulnerability.component_id == component_id)
    if severity:
        query = query.filter(Vulnerability.severity == severity)
    
    # Apply pagination
    query = query.offset(skip).limit(limit)
    
    # Return results
    db_vulnerabilities = query.all()
    
    # Convert to Pydantic models using helper function
    return [db_vulnerability_to_model(db_vuln) for db_vuln in db_vulnerabilities]


def count_vulnerabilities(
    db: Session, 
    component_id: Optional[str] = None,
    severity: Optional[str] = None
) -> int:
    """Count vulnerabilities with optional filtering"""
    query = db.query(Vulnerability)
    
    # Apply filters if provided
    if component_id:
        query = query.filter(Vulnerability.component_id == component_id)
    if severity:
        query = query.filter(Vulnerability.severity == severity)
    
    # Return count
    return query.count()


def create_vulnerability(db: Session, vulnerability: VulnerabilityCreate) -> VulnerabilityModel:
    """Create a new vulnerability"""
    # Generate a unique ID for the vulnerability
    vulnerability_id = vulnerability.vulnerability_id or f"VULN-{uuid.uuid4().hex[:8]}"
    
    # Create the vulnerability
    db_vulnerability = Vulnerability(
        vulnerability_id=vulnerability_id,
        name=vulnerability.name,
        description=vulnerability.description,
        severity=vulnerability.severity,
        cvss_score=vulnerability.cvss_score,
        cvss_vector=vulnerability.cvss_vector,
        affected_components=vulnerability.affected_components,
        attack_vector=vulnerability.attack_vector,
        attack_complexity=vulnerability.attack_complexity,
        privileges_required=vulnerability.privileges_required,
        user_interaction=vulnerability.user_interaction,
        scope=vulnerability.scope,
        confidentiality_impact=vulnerability.confidentiality_impact,
        integrity_impact=vulnerability.integrity_impact,
        availability_impact=vulnerability.availability_impact,
        exploitability_score=vulnerability.exploitability_score,
        impact_score=vulnerability.impact_score,
        created_at=datetime.now(),
        updated_at=datetime.now()
    )
    
    # Add to database
    db.add(db_vulnerability)
    db.commit()
    db.refresh(db_vulnerability)
    
    return db_vulnerability_to_model(db_vulnerability)


def update_vulnerability(
    db: Session, 
    vulnerability_id: str, 
    vulnerability_update: VulnerabilityUpdate
) -> Optional[VulnerabilityModel]:
    """Update an existing vulnerability"""
    # Get the vulnerability
    db_vulnerability = db.query(Vulnerability).filter(Vulnerability.vulnerability_id == vulnerability_id).first()
    if not db_vulnerability:
        return None
    
    # Update the vulnerability fields
    update_data = vulnerability_update.dict(exclude_unset=True)
    for key, value in update_data.items():
        setattr(db_vulnerability, key, value)
    
    # Update the updated_at timestamp
    db_vulnerability.updated_at = datetime.now()
    
    # Commit changes
    db.commit()
    db.refresh(db_vulnerability)
    
    return db_vulnerability_to_model(db_vulnerability)


def delete_vulnerability(db: Session, vulnerability_id: str) -> bool:
    """Delete a vulnerability by its ID"""
    # Get the vulnerability
    db_vulnerability = db.query(Vulnerability).filter(Vulnerability.vulnerability_id == vulnerability_id).first()
    if not db_vulnerability:
        return False
    
    # Delete the vulnerability
    db.delete(db_vulnerability)
    db.commit()
    
    return True


def scan_component_for_vulnerabilities(db: Session, component: Component) -> List[Dict[str, Any]]:
    """
    Scan a single component for potential vulnerabilities
    
    This is a simplified algorithm that identifies potential vulnerabilities based on:
    1. Component type (e.g., ECU, Sensor)
    2. Interfaces used (e.g., CAN, Bluetooth)
    3. Trust zone configuration
    
    Real-world scanning would involve more sophisticated techniques.
    """
    vulnerabilities = []
    
    # Check component type vulnerabilities
    component_type = component.type
    if component_type in COMPONENT_VULNERABILITY_MAPPING:
        for vuln_template in COMPONENT_VULNERABILITY_MAPPING[component_type]:
            vuln_data = vuln_template.copy()
            # Add component type to affected_components
            affected_components = vuln_data.get("affected_components", []) or []
            if component_type not in affected_components:
                affected_components.append(component_type)
            
            # Update with component-specific info
            vuln_data.update({
                "affected_components": affected_components,
                "vulnerability_id": f"VULN-{uuid.uuid4().hex[:8]}"
            })
            vulnerabilities.append(vuln_data)
    
    # Check interface-specific vulnerabilities
    if component.interfaces:
        for interface in component.interfaces:
            if interface in INTERFACE_VULNERABILITY_MAPPING:
                for vuln_template in INTERFACE_VULNERABILITY_MAPPING[interface]:
                    vuln_data = vuln_template.copy()
                    # Add component type and interface to affected_components
                    affected_components = vuln_data.get("affected_components", []) or []
                    if component_type not in affected_components:
                        affected_components.append(component_type)
                    if interface not in affected_components:
                        affected_components.append(interface)
                    
                    # Update with component-specific info
                    vuln_data.update({
                        "affected_components": affected_components,
                        "vulnerability_id": f"VULN-{uuid.uuid4().hex[:8]}"
                    })
                    vulnerabilities.append(vuln_data)
    
    # Check trust zone vulnerabilities
    if component.trust_zone in TRUST_ZONE_VULNERABILITY_MAPPING:
        for vuln_template in TRUST_ZONE_VULNERABILITY_MAPPING[component.trust_zone]:
            vuln_data = vuln_template.copy()
            # Add component type and trust zone to affected_components
            affected_components = vuln_data.get("affected_components", []) or []
            if component_type not in affected_components:
                affected_components.append(component_type)
            if component.trust_zone not in affected_components and component.trust_zone != "Standard":
                affected_components.append(component.trust_zone)
            
            # Update with component-specific info
            vuln_data.update({
                "affected_components": affected_components,
                "vulnerability_id": f"VULN-{uuid.uuid4().hex[:8]}"
            })
            vulnerabilities.append(vuln_data)
    
    return vulnerabilities


def perform_vulnerability_assessment(db: Session, component_ids: List[str]) -> VulnerabilityAssessmentResult:
    """
    Perform a vulnerability assessment on the specified components
    
    This function:
    1. Retrieves each component by ID
    2. Scans each component for potential vulnerabilities
    3. Stores identified vulnerabilities in the database
    4. Returns a comprehensive assessment result
    """
    if not component_ids:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="At least one component ID must be provided"
        )
    
    # Generate unique assessment ID
    assessment_id = f"VA-{uuid.uuid4()}"
    
    # Track assessment metrics
    total_components = len(component_ids)
    total_vulnerabilities = 0
    high_severity_vulnerabilities = 0
    component_assessments = []
    scope_id = None
    
    # Process each component
    for component_id in component_ids:
        # Get the component
        component = db.query(Component).filter(Component.component_id == component_id).first()
        if not component:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Component with ID {component_id} not found"
            )
        
        # Store scope_id for the assessment
        if not scope_id and component.scope_id:
            scope_id = component.scope_id
        
        # Scan for vulnerabilities
        vulnerabilities = scan_component_for_vulnerabilities(db, component)
        
        # Store vulnerabilities in the database
        component_vulnerability_ids = []
        for vuln_data in vulnerabilities:
            # Create vulnerability in database
            vuln_create = VulnerabilityCreate(**vuln_data)
            db_vuln = create_vulnerability(db, vuln_create)
            component_vulnerability_ids.append(db_vuln.vulnerability_id)
            
            # Update metrics
            total_vulnerabilities += 1
            if db_vuln.severity in ["High", "Critical"]:
                high_severity_vulnerabilities += 1
        
        # Add component assessment to result
        component_assessment = {
            "component_id": component_id,
            "component_name": component.name,
            "component_type": component.type,
            "total_vulnerabilities": len(vulnerabilities),
            "high_severity_vulnerabilities": sum(1 for v in vulnerabilities if v["severity"] in ["High", "Critical"]),
            "vulnerability_ids": component_vulnerability_ids
        }
        component_assessments.append(component_assessment)
    
    # Create and return assessment result
    result = VulnerabilityAssessmentResult(
        assessment_id=assessment_id,
        component_assessments=component_assessments,
        total_components=total_components,
        total_vulnerabilities=total_vulnerabilities,
        high_severity_vulnerabilities=high_severity_vulnerabilities,
        created_at=datetime.now(),
        scope_id=scope_id
    )
    
    return result
